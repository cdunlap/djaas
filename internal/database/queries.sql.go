// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createJoke = `-- name: CreateJoke :one
INSERT INTO jokes (setup, punchline, category)
VALUES ($1, $2, $3)
RETURNING id, setup, punchline, category, created_at, updated_at
`

type CreateJokeParams struct {
	Setup     string      `json:"setup"`
	Punchline string      `json:"punchline"`
	Category  pgtype.Text `json:"category"`
}

func (q *Queries) CreateJoke(ctx context.Context, arg CreateJokeParams) (Joke, error) {
	row := q.db.QueryRow(ctx, createJoke, arg.Setup, arg.Punchline, arg.Category)
	var i Joke
	err := row.Scan(
		&i.ID,
		&i.Setup,
		&i.Punchline,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllTags = `-- name: GetAllTags :many
SELECT name
FROM tags
ORDER BY name ASC
`

func (q *Queries) GetAllTags(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJokeByAllFilters = `-- name: GetJokeByAllFilters :one
SELECT DISTINCT j.id, j.setup, j.punchline, j.category, j.created_at, j.updated_at
FROM jokes j
INNER JOIN joke_tags jt ON j.id = jt.joke_id
INNER JOIN tags t ON jt.tag_id = t.id
WHERE t.name = ANY($1::text[])
  AND j.category = $2
  AND (j.setup ILIKE '%' || $3 || '%' OR j.punchline ILIKE '%' || $3 || '%')
ORDER BY RANDOM()
LIMIT 1
`

type GetJokeByAllFiltersParams struct {
	Column1  []string    `json:"column_1"`
	Category pgtype.Text `json:"category"`
	Column3  pgtype.Text `json:"column_3"`
}

func (q *Queries) GetJokeByAllFilters(ctx context.Context, arg GetJokeByAllFiltersParams) (Joke, error) {
	row := q.db.QueryRow(ctx, getJokeByAllFilters, arg.Column1, arg.Category, arg.Column3)
	var i Joke
	err := row.Scan(
		&i.ID,
		&i.Setup,
		&i.Punchline,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJokeByCategory = `-- name: GetJokeByCategory :one
SELECT id, setup, punchline, category, created_at, updated_at
FROM jokes
WHERE category = $1
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetJokeByCategory(ctx context.Context, category pgtype.Text) (Joke, error) {
	row := q.db.QueryRow(ctx, getJokeByCategory, category)
	var i Joke
	err := row.Scan(
		&i.ID,
		&i.Setup,
		&i.Punchline,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJokeByCategoryAndSearch = `-- name: GetJokeByCategoryAndSearch :one
SELECT id, setup, punchline, category, created_at, updated_at
FROM jokes
WHERE category = $1
  AND (setup ILIKE '%' || $2 || '%' OR punchline ILIKE '%' || $2 || '%')
ORDER BY RANDOM()
LIMIT 1
`

type GetJokeByCategoryAndSearchParams struct {
	Category pgtype.Text `json:"category"`
	Column2  pgtype.Text `json:"column_2"`
}

func (q *Queries) GetJokeByCategoryAndSearch(ctx context.Context, arg GetJokeByCategoryAndSearchParams) (Joke, error) {
	row := q.db.QueryRow(ctx, getJokeByCategoryAndSearch, arg.Category, arg.Column2)
	var i Joke
	err := row.Scan(
		&i.ID,
		&i.Setup,
		&i.Punchline,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJokeByID = `-- name: GetJokeByID :one
SELECT id, setup, punchline, category, created_at, updated_at
FROM jokes
WHERE id = $1
`

func (q *Queries) GetJokeByID(ctx context.Context, id int32) (Joke, error) {
	row := q.db.QueryRow(ctx, getJokeByID, id)
	var i Joke
	err := row.Scan(
		&i.ID,
		&i.Setup,
		&i.Punchline,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJokeByTags = `-- name: GetJokeByTags :one
SELECT DISTINCT j.id, j.setup, j.punchline, j.category, j.created_at, j.updated_at
FROM jokes j
INNER JOIN joke_tags jt ON j.id = jt.joke_id
INNER JOIN tags t ON jt.tag_id = t.id
WHERE t.name = ANY($1::text[])
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetJokeByTags(ctx context.Context, dollar_1 []string) (Joke, error) {
	row := q.db.QueryRow(ctx, getJokeByTags, dollar_1)
	var i Joke
	err := row.Scan(
		&i.ID,
		&i.Setup,
		&i.Punchline,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJokeByTagsAndCategory = `-- name: GetJokeByTagsAndCategory :one
SELECT DISTINCT j.id, j.setup, j.punchline, j.category, j.created_at, j.updated_at
FROM jokes j
INNER JOIN joke_tags jt ON j.id = jt.joke_id
INNER JOIN tags t ON jt.tag_id = t.id
WHERE t.name = ANY($1::text[])
  AND j.category = $2
ORDER BY RANDOM()
LIMIT 1
`

type GetJokeByTagsAndCategoryParams struct {
	Column1  []string    `json:"column_1"`
	Category pgtype.Text `json:"category"`
}

func (q *Queries) GetJokeByTagsAndCategory(ctx context.Context, arg GetJokeByTagsAndCategoryParams) (Joke, error) {
	row := q.db.QueryRow(ctx, getJokeByTagsAndCategory, arg.Column1, arg.Category)
	var i Joke
	err := row.Scan(
		&i.ID,
		&i.Setup,
		&i.Punchline,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJokeByTagsAndSearch = `-- name: GetJokeByTagsAndSearch :one
SELECT DISTINCT j.id, j.setup, j.punchline, j.category, j.created_at, j.updated_at
FROM jokes j
INNER JOIN joke_tags jt ON j.id = jt.joke_id
INNER JOIN tags t ON jt.tag_id = t.id
WHERE t.name = ANY($1::text[])
  AND (j.setup ILIKE '%' || $2 || '%' OR j.punchline ILIKE '%' || $2 || '%')
ORDER BY RANDOM()
LIMIT 1
`

type GetJokeByTagsAndSearchParams struct {
	Column1 []string    `json:"column_1"`
	Column2 pgtype.Text `json:"column_2"`
}

func (q *Queries) GetJokeByTagsAndSearch(ctx context.Context, arg GetJokeByTagsAndSearchParams) (Joke, error) {
	row := q.db.QueryRow(ctx, getJokeByTagsAndSearch, arg.Column1, arg.Column2)
	var i Joke
	err := row.Scan(
		&i.ID,
		&i.Setup,
		&i.Punchline,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRandomJoke = `-- name: GetRandomJoke :one
SELECT id, setup, punchline, category, created_at, updated_at
FROM jokes
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomJoke(ctx context.Context) (Joke, error) {
	row := q.db.QueryRow(ctx, getRandomJoke)
	var i Joke
	err := row.Scan(
		&i.ID,
		&i.Setup,
		&i.Punchline,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagsForJoke = `-- name: GetTagsForJoke :many
SELECT t.name
FROM tags t
INNER JOIN joke_tags jt ON t.id = jt.tag_id
WHERE jt.joke_id = $1
ORDER BY t.name
`

func (q *Queries) GetTagsForJoke(ctx context.Context, jokeID int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getTagsForJoke, jokeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchJokes = `-- name: SearchJokes :one
SELECT id, setup, punchline, category, created_at, updated_at
FROM jokes
WHERE setup ILIKE '%' || $1 || '%'
   OR punchline ILIKE '%' || $1 || '%'
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) SearchJokes(ctx context.Context, dollar_1 pgtype.Text) (Joke, error) {
	row := q.db.QueryRow(ctx, searchJokes, dollar_1)
	var i Joke
	err := row.Scan(
		&i.ID,
		&i.Setup,
		&i.Punchline,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
